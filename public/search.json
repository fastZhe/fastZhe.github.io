[{"title":"设计模式之对象池模式","url":"/2018/07/20/对象池模式-2018-07-20/","content":"\n## 设计模式之对象池模式\n* 23中模式之外的新模式\n\n### 简介\n对象池模式就是依赖于内存中的对象池（在应用启动时进行初始化），通过循环使用对象，减少资源初始化、以及销毁的昂贵损耗！典型的例子是：线程池、连接池\n\n\n### 类图\n![对象池](images/2018-07-19-3.png)\n<center>对象池</center>\n\n\n\n### 最佳实践\n只有在重复生成对象的操作成为影响性能的关键因素时，才适合进行对象池化，但是若池化带来性能提高并不显著或重要的话，建议放弃对象池化技术。\n\n\n### 代码\n```\npackage com.bj.hz.pool;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 8:41 PM\n */\npublic abstract class Pool <T>{\n    private  Map<T,ObjectStatus> pool=new HashMap();\n\n    public Pool() {\n        pool.put(create(),new ObjectStatus());\n    }\n\n    public synchronized T checkout(){\n        for (T t:pool.keySet()){\n            if (!pool.get(t).isIsuse()){\n                pool.get(t).setIsuse(true);\n                return t;\n            }\n        }\n        return null;\n    }\n\n\n    public synchronized void checkIn(T t){\n        pool.get(t).setIsuse(false);\n    }\n\n    public abstract T create();\n\n    private static class ObjectStatus{\n        private boolean isuse;\n\n        public boolean isIsuse() {\n            return isuse;\n        }\n\n        public void setIsuse(boolean isuse) {\n            this.isuse = isuse;\n        }\n\n\n\n    }\n}\n```","tags":["设计模式"],"categories":["power design"]},{"title":"设计模式之规格模式","url":"/2018/07/19/规格模式-2018-07-19/","content":"\n## 设计模式之规格模式\n* 23中模式之外的新模式\n\n### 简介\n在一系列对象中根据条件搜索！类似sql，但不同的是从内存中的对象进行搜索\n具体类似于LINQ（Language Integrated Query）语言集成查询\n\n### 初步实践\n> 1.创建一个接口，实现按照某种条件筛选：IUserProvider\n  2.实现以上接口:UserProvider，通过具体的对象类进行抽象方法的实现（例如：遍历实体类数组，进行判断，然后返回结果数组或列表）\n  3.实现具体对象，类似User实体类\n  4.实现场景类，初始化一个拥有User的数组或列表，实例化UserProvider，并使用相关方法，获取结果\n\n* 请注意以上实现，我们可以发现一旦业务发生变更，我们需要改对应的接口方法、需要实现对应的接口，很不容易进行扩展。\n\n* 第二种：那么我们是否可以将对应的搜索条件进行封装，创建一个接口：IUserSpecification，定义是否满足的方法，返回bool值，这样就可以在多种条件下（业务变更等），进行无缝扩展。只用实现该接口，就可以扩展多个条件类。\n\n* 对于类似于sql的多个条件查询下，在数据量大的情况下容易造成性能较差，因为需要经过好多轮循环\n\n* 第三种：可以知道一般条件组合，基本离不开与或非、这三种模式是固定的，我们可以通过这三种模式进行统一的条件封装。\n> 1.我们创建一个条件规格接口：IUserSpecification,实现判断是否满足，返回bool值\n  2.创建一个抽象类实现IUserSpecification：ComposionSpecificaiton，并且通过模板方法实现与或非三种条件规格的生成，具体接口的实现由具体类来实现。此抽象类依赖于具体的实现（请按照实际情况分析，不要死学）\n  3.继承ComposionSpecificaiton，实现具体的判断方法\n  4.在场景类中，通过条件规格的实现类，使用与或非方法对多个条件进行封装，然后进行计算\n\n#### 第三种方法最优，使用了组合模式、策略模式、模板模式这三种模式组合成了规格模式。\n\n### 类图\n\n![第二种类图](images/2018-07-19-2.jpg)\n<center>第二种类图</center>\n\n![第三种类图](images/2018-07-19-1.jpg)\n<center>第三种类图</center>\n\n\n### 以下为代码\n\n* 定义一个用户：\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-18\n * @time: 9:48 PM\n */\npublic class User {\n    private String name;\n    private int age;\n\n    public User(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n\n```\n* 定义一个查询提供类接口以及实现\n\n```\npackage com.bj.hz.specification.very;\n\n\nimport java.util.ArrayList;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-18\n * @time: 10:07 PM\n */\npublic interface IUserProvider {\n    ArrayList<User> findUser(IUserSpecification specification);\n}\n\n```\n* 提供实现\n```\npackage com.bj.hz.specification.very;\n\n\n\nimport java.util.ArrayList;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-18\n * @time: 10:09 PM\n */\npublic class UserProvider implements IUserProvider {\n\n    private ArrayList<User> users;\n\n    public UserProvider(ArrayList<User> users) {\n        this.users = users;\n    }\n\n    @Override\n    public ArrayList<User> findUser(IUserSpecification specification) {\n        ArrayList<User> result=new ArrayList<>();\n        for (User u:users){\n            if (specification.isSatisfiedBy(u)){\n                result.add(u);\n            }\n        }\n        return result;\n    }\n}\n\n```\n* 规格条件接口\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:为了适应未来变化的需求，将运算封装到接口之内\n *\n * @author: huangzhe\n * @date: 2018-07-18\n * @time: 10:02 PM\n */\npublic interface IUserSpecification {\n    public boolean isSatisfiedBy(User user);\n}\n\n```\n* 组合模式的接口，其实可以定义三个装饰器（请自行想象）分别实现 与或非\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:06 AM\n */\npublic abstract class AbstractComposition implements IUserSpecification {\n\n\n\n    public IUserSpecification and(IUserSpecification userSpecification){\n        return new AndSpecification(this,userSpecification);\n    }\n\n    public IUserSpecification or(IUserSpecification userSpecification){\n        return new OrSpecification(this,userSpecification);\n    }\n    public IUserSpecification not(IUserSpecification userSpecification){\n        return new NotSpecification(this);\n    }\n\n}\n\n```\n* 分别是与或非实现\n\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:08 AM\n */\npublic class AndSpecification extends AbstractComposition {\n\n    private IUserSpecification _left;\n    private IUserSpecification _right;\n\n    public AndSpecification(IUserSpecification _left, IUserSpecification _right) {\n        this._left = _left;\n        this._right = _right;\n    }\n\n    @Override\n    public boolean isSatisfiedBy(User user) {\n        return _left.isSatisfiedBy(user) && _right.isSatisfiedBy(user);\n    }\n}\n\n\n```\n\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:09 AM\n */\npublic class OrSpecification extends AbstractComposition {\n\n    private IUserSpecification _left;\n    private IUserSpecification _right;\n\n    public OrSpecification(IUserSpecification _left, IUserSpecification _right) {\n        this._left = _left;\n        this._right = _right;\n    }\n\n    @Override\n    public boolean isSatisfiedBy(User user) {\n        return _left.isSatisfiedBy(user) || _right.isSatisfiedBy(user);\n    }\n}\n\n```\n\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:10 AM\n */\npublic class NotSpecification extends AbstractComposition {\n\n    private IUserSpecification userSpecification;\n\n    public NotSpecification(IUserSpecification userSpecification) {\n        this.userSpecification = userSpecification;\n    }\n\n    @Override\n    public boolean isSatisfiedBy(User user) {\n        return !userSpecification.isSatisfiedBy(user);\n    }\n}\n\n```\n* 根据名称查询\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:29 AM\n */\npublic class FindByNameSpecification extends AbstractComposition {\n\n    private String name;\n\n    public FindByNameSpecification(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public boolean isSatisfiedBy(User user) {\n        return user.getName().equals(name);\n    }\n}\n\n```\n* 根据大于给定的年龄查询\n```\npackage com.bj.hz.specification.very;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-19\n * @time: 9:31 AM\n */\npublic class FindByAgeThanSpecification extends AbstractComposition {\n\n    private int age;\n\n    public FindByAgeThanSpecification(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public boolean isSatisfiedBy(User user) {\n        return user.getAge()>age;\n    }\n}\n\n```\n\n* 场景类具体实现\n```\npackage com.bj.hz.specification.very;\n\n\n\n\nimport java.util.ArrayList;\n\n/**\n * Created with hzz\n * Description:\n *\n * @author: huangzhe\n * @date: 2018-07-18\n * @time: 10:12 PM\n */\npublic class Client {\n    public static void main(String[] args) {\n        ArrayList<User> users = new ArrayList<>();\n        users.add(new User(\"121\", 3));\n        users.add(new User(\"犁牛\", 10));\n        users.add(new User(\"测试\", 18));\n        users.add(new User(\"hah\", 16));\n        users.add(new User(\"黄啦啦\", 19));\n        users.add(new User(\"吴啦啦\", 20));\n        System.out.println(\"========年龄大于16的==========\");\n        IUserProvider userProvider=new UserProvider(users);\n        for (User user:userProvider.findUser(new FindByNameSpecification(\"hah\").and(new FindByAgeThanSpecification(14)))){\n            System.out.println(user);\n        }\n\n    }\n}\n\n```\n\n\n\n","tags":["设计模式"],"categories":["power design"]},{"title":"solr安装分词","url":"/2018/04/03/solr安装分词/","content":"\n* 环境 centos7\n### 下载solr\n`地址：http://www.apache.org/dyn/closer.lua/lucene/solr/7.2.1`\n\n#### 解压\n```bash\ntar -xvf solr-7.2.1.tgz\n\n```\n### 1. 直接使用solr\n```\ncd solrHome(solrHome是solr的路径)\ncd bin\nsolr start\n```\n#### 1.1. 创建core 或者collection 意义一致\n```bash\nsolr create -c articles\n控制台：http://127.0.0.1:8983/solr\n```\n\n#### 1.2. 创建分词器\n```bash\n下载地址：https://pan.baidu.com/s/1smOxPhF\n将解分词资料里的ik-analyzer-solr5-5.x.jar拷贝到你的solr目录下的\\server\\solr-webapp\\webapp\\WEB-INF\\lib目录中去，\n将IKAnalyzer.cfg.xml，mydict.dic（搜狗的扩展词库），stopword.dic放在你的solr目录下的\\server\\solr-webapp\\webapp\\WEB-INF\\classes目录中去\n\n\n修改 articles集合目录下的managed-schema\n\n添加以下4行：\n\n<fieldType name=\"text_ik\" class=\"solr.TextField\">  \n        <analyzer class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/>  \n</fieldType>  \n\n\n重启或者reload\n\n```\n#### 1.3. 创建字段\n```\n{\n    \"add-field\" : {\n        \"name\" : \"name\",\n        \"type\" : \"text_ik\"\n    },\n    \"add-field\" : {\n        \"name\" : \"content\",\n        \"type\" : \"text_ik\",\n        \"stored\" : \"true\"\n    },\n    \"add-field\" : {\n        \"name\" : \"createTime\",\n        \"type\" : \"date\"\n    }\n}\n\npost提交：\nhttp://localhost:8983/solr/articles/schema\n```\n\n#### 1.4. 删除字段\n\n```\n{\n    \"delete-field\" : {\n        \"name\" : \"name\"\n    },\n    \"delete-field\" : {\n        \"name\" : \"content\"\n    }\n}\nhttp://localhost:8983/solr/articles/schema\n```\n\n\n### 2. 使用tomcat作为容器运行solr\n#### 2.1 新创建一个solr_home_new文件夹\n\n```\nexport solr_home=/app/solr-7.2.1\nexport solr_home_new=/app/solr_home\n\n复制 ${solr_home}/server/solr-webapp/webapp 并重命名 ${tomcat}/webapp/solr\ncp -r ${solr_home}/dist  ${solr_home_new}/\ncp ${solr_home}/server/lib/ext/*.jar ${tomcat}/webapp/solr/WEB-INF/lib/\ncp ${solr_home}/server/lib/*.jar ${tomcat}/webapp/solr/WEB-INF/lib/\n#classes文件夹没有自己创建\ncp ${solr_home}/server/resources/log4j.properties ${tomcat}/webapp/solr/WEB-INF/classes \n\n\n#进入 ${tomcat}/webapp/solr/WEB-INF/ 修改web.xml\n修改：修改中间为自己的solr_home_new，我的solr_home_new为solr_home/solr\n\n <env-entry>\n         <env-entry-name>solr/home</env-entry-name>\n         <env-entry-value>/Users/huangzhe/app/solr_home/solr</env-entry-value>\n         <env-entry-type>java.lang.String</env-entry-type>\n</env-entry>\n并注释以下，防止403：\n<!--  <security-constraint>\n    <web-resource-collection>\n      <web-resource-name>Disable TRACE</web-resource-name>\n      <url-pattern>/</url-pattern>\n      <http-method>TRACE</http-method>\n    </web-resource-collection>\n    <auth-constraint/>\n  </security-constraint>\n  <security-constraint>\n    <web-resource-collection>\n      <web-resource-name>Enable everything but TRACE</web-resource-name>\n      <url-pattern>/</url-pattern>\n      <http-method-omission>TRACE</http-method-omission>\n    </web-resource-collection>\n  </security-constraint>\n-->\n\n```\n\n\n#### 2.2 创建core\n```\ncp -r ${solr_home}/server/solr ${solr_home_new}/\ncd ${solr_home_new}/solr\nmkdir new_core\ncp -r configsets/_default/conf new_core\n\n打开浏览器：http://localhost:8080/solr/index.html\n点击：core Admin ,然后更改schema.xml为 managed-schema，点击确定\n```\n\n\n#### 2.3 添加分词器\n与1.2一致，在tomcat下面对应的路径去改\n","tags":["search"],"categories":["solr"]},{"title":"localtunnel server端搭建","url":"/2018/03/15/localtunnel-server端搭建/","content":"\n## localtunnel server\n### 下载程序\n> 以下地址为localtunnel server的git页面\n\n`https://github.com/localtunnel/server`\n\n> 下载安装\n\n* 前提：本机安装git、 nodejs \n* 有独立域名、独立主机（公网ip）\n\n```bash\n$ git clone  https://github.com/localtunnel/server.git\n$ cd localtunnel-server\n$ npm install\n```\n\n> 启动\n\n```bash\n# 直接使用\n$ bin/server --port 2000\n# 配合 pm2 使用\n$ pm2 start bin/server --name lt -- --port 2000\n```\n\n> server配合nginx使用\n\n* 配置如下：\n\n```nginx\nupstream server {\n\n                server 127.0.0.1:8099;\n        }\nmap $http_upgrade $connection_upgrade {\n    default upgrade;\n    ''      close;\n}\n\nserver {\n        listen 80 default_server;\n        server_name example.com;\n    location / {\n        proxy_pass http://server;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-Proto http;\n        proxy_set_header X-NginX-Proxy true;\n     #  proxy_set_header Upgrade $http_upgrade;\n     #  proxy_set_header Connection $connection_upgrade;\n\n        proxy_redirect off;\n                }\n        }\n\n server {\n        listen       443 default_server ssl;\n        server_name  example.com;\n        ssl on;\n        ssl_certificate      /etc/letsencrypt/live/example.com/fullchain.pem;\n        ssl_certificate_key  /etc/letsencrypt/live/example.com/privkey.pem;\n\n        ssl_session_cache    shared:SSL:1m;\n        ssl_session_timeout  5m;\n\n        ssl_ciphers  HIGH:!aNULL:!MD5;\n        ssl_prefer_server_ciphers  on;\n\n        location / {\n\n        proxy_pass http://server/;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-Proto https;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $connection_upgrade;\n\n        proxy_set_header X-NginX-Proxy true;\n        proxy_redirect off;\n        }\n    }\n```\n\n\n> client端使用\n\n```bash\n# 安装client端\n$ npm i localtunnel -g\n# 使用localtunnel默认服务器启动本地监听8080端口\n$ lt --port 8080\n# 使用自己搭建的服务器启动监听本地8080端口\n$ lt -h http://example.com --port 8080\n# 指定二级域名启动监听\n$ lt -s ceshi -h http://example.com --port 8080 \n```\n\n\n","tags":["内网穿透"],"categories":["内网穿透"]},{"title":"读源码注意的东西","url":"/2018/02/06/读源码注意的东西/","content":"## 修改相关\n###### 2018/2/6  创建\n\n## 怎样读源码，该注意什么问题\n\n*前提：读懂源码的动机与原因是什么。*\n     *看下该项目的设计文档与架构图，宏观上对一些概念有些认识*\n     *从感兴趣的点设置断点、开始debug*\n\n\n* 了解语言\n* 了解设计模式\n* 了解命名习惯-统一规约\n* 是了解整体架构，而不是地毯式遍历每一行代码\n* 了解架构： 从上至下（要有层次感） 层级、每个层级由多个角色构成，角色的互动\n    系统如何初始化（为接下来的所有任务做准备）-> 系统的相关的其他系统（界面等||设定系统的边界）-> 系统如何反应事件-> 系统如何处理异常与错误\n\n","tags":["方法"],"categories":["java"]},{"title":"字符串反转","url":"/2018/02/05/字符串反转/","content":"\n## 以下为字符串反转的几种方法\n\n### 遍历字符数组\n\n```java\n\n    public static void reverse3(String src){\n        if(src==null){\n            throw new IllegalArgumentException(src);\n        }\n        int length=src.length();\n        char[] srcChar=src.toCharArray();\n        for(int i=0;i<length/2;i++){\n            char temp=srcChar[i];\n            srcChar[i]=srcChar[length-i-1];\n            srcChar[length-i-1]=temp;\n        }\n        System.out.println(new String(srcChar));\n    }\n\n\n\n    public static void reverse1(String src){\n        if(src==null){\n            throw new IllegalArgumentException(src);\n        }\n        int length=src.length();\n        char[] dest=new char[length];\n        char[] srcChar=src.toCharArray();\n        for(int i=0;i<length;i++){\n            dest[i]=srcChar[length-i-1];\n        }\n        System.out.println(new String(dest));\n    }\n```\n\n### 递归\n\n```java\n public static String reverse4(String src){\n        if(src==null){\n            throw new IllegalArgumentException(src);\n        }\n        int length=src.length();\n        if(length<=1){\n            return src;\n        }\n        String left=src.substring(0,length/2);\n        String right=src.substring(length/2,length);\n        return reverse4(right)+reverse4(left);\n\n    }\n\n\n```\n\n### 使用StringBuffer\n\n```java\n\n public static void reverse2(String src){\n        if(src==null){\n            throw new IllegalArgumentException(src);\n        }\n        StringBuffer sb=new StringBuffer(src);\n        sb.reverse();\n        System.out.println(sb.toString());\n    }\n\n```","tags":["工具"],"categories":["java"]},{"title":"linux删除文件除过某个文件","url":"/2018/02/01/linux删除文件除过某个文件/","content":"\n### 使用rm \n> 删除除了file1 的文件\n\n\n\n```bash\nrm -fr !(file1)\n```\n\n\n### 使用find\n> 删除除了file1\n\n```bash\nfind ./* -not -name \"file1\" | xargs rm -fr\nfind ./* -not -name \"file1\" -exec rm -fr {} \\;\n```\n\n\n\n","tags":["find"],"categories":["shell"]},{"title":"linux下使用rsync快速删除大量文件","url":"/2018/01/31/linux下使用rsync快速删除大量文件/","content":"\n## 问题：快速删除一个文件夹下的大量文件？\n* 使用rm 大量文件会很慢，更大时并且会报错\n> 实际原理：遍历删除\n\n```bash\n$ rm -fr *\n```\n\n* 使用rsync删除\n> 实际原理：使用空文件夹替换要删除的文件夹\n\n\n\n```bash\n#建立新的空文件夹\n$ mkdir src\n#建立实际有很多文件的文件夹\n$ mkdir dest\n#模拟生成大量文件  900000个文件\n$ touch file{1..900000}\n#使用rsync删除\n# -r 包含文件夹 -l 符号链接 -p 权限 permission -t 保持文件修改时间 -D 特殊设备\n$ rsync --delete-before -rlptD src/ dest\n#或者(与上面一样的效果)\n$ rsync -a --delete-before --no-o --no-g src/ dest\n```\n","tags":["rm"],"categories":["shell"]},{"title":"hexo安装部署教程","url":"/2018/01/30/hexo安装部署教程/","content":"##    建立一个\bgithubpage项目\n### 使用自定义域名访问博客的前提：\n> 有域名解析至你的github page 我的域名为：blog.wudd.top\n\n\n####   建立一个分支 hexo\n* hexo为项目管理分支，即hexo博客项目的主分支\n* master分支为博客展示页面的分支（\b建好项目即存在的分支）\n\n##  在本地 \bclone hexo 分支\n\n```bash\n#克隆hexo分支\n$ git clone -b hexo git地址\n#进入\b克隆好的项目\n$ cd 项目名\n```\n##  安装hexo 以及相关的主题\n```bash\n#全局安装hexo\n$ sudo npm install -g hexo-cli\n#初始化hexo\n$ hexo init .\n```\n####  编辑项目目录下的 _config.yml文件\n##### ps\n* site:为博客自定义\b内容\n* 主题theme：主题配置项为第四步安装的，默认为自带的，也可不修改\n* deploy:填写自己的githubpage地址，分支为master\n* url:填写自己的博客访问url\n```bash\n#编辑项目根目录下的配置文件，修改以下其他可不修改：\b\n$ vim _config.yml\n \n  5 # Site\n  6 title: Hzhe\n  7 subtitle: you...\n  8 description: blog java\n  9 author: hzz\n 10 language:\n 11 timezone:\n 12\n 13 # URL\n 14 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/ch    ild' and root as '/child/'\n 15 url: http://blog.wudd.top\n 16 root: /\n 17 permalink: :year/:month/:day/:title/\n 18 permalink_defaults:\n# Extensions\n 73 ## Plugins: https://hexo.io/plugins/\n 74 ## Themes: https://hexo.io/themes/ \n 75 theme: hexo-theme-laughing\n 76\n 77 # Deployment\n 78 ## Docs: https://hexo.io/docs/deployment.html\n 79 deploy:\n 80   type: git\n 81   repo: https://github.com/fastZhe/fastZhe.github.io\n 82   branch: master\n\n```\n##  安装hexo相关的主题\n* signature:个人签名\n* author.head:个人头像\n* navication:菜单栏\n* copyright：建议都关闭\n* socail:社交媒体连接\n```bash\n#进入theme文件夹\n$ cd theme\n#安装主题（不是必须）\n$ npm install hexo-renderer-pug --save\n$ git clone git@github.com:BoizZ/hexo-theme-laughing.git\n#删除主题文件夹内的.git\n$ cd hexo-theme-laughing ; rm -fr .git\n#编辑主题配置文件\n$ vim _config.yml\n\n  6 page_background: http://callfiles.ueibo.com/hexo-theme-laughing/page_backgro    und.jpg\n  7 page_menu_button: dark\n  8 post_background: http://callfiles.ueibo.com/hexo-theme-laughing/post_backgro    und.jpg\n  9 post_menu_button: light\n 10 title_plancehold: 随笔\n 11 author:\n 12   head: https://tva3.sinaimg.cn/crop.0.0.750.750.180/cbe52eb6jw8ew3l78tj4qj2    0ku0kv75s.jpg\n 13   signature: 世界那么大，我想去看看。。。KEEP FIGHTING\n 14 navication:\n 15   - name: Github\n 16     link: https://github.com/fastZhe\n 17 # content\n 18 content_width: 800\n\n 21 social:\n 22   - name: Github\n 23     icon: github\n 24     link: https://github.com\n 25   - name: Weibo\n 26     icon: weibo\n 27     link: https://weibo.com/p/1005053420794550/home?from=page_100505&mod=TAB    &is_all=1\n\n # Copyright\n 33 copyright:\n 34   record: false\n 35   hexo: false\n 36   laughing: true\n```\n\n##  编辑githubpage 项目根目录下的.gitignore\n* 配置成以下：避免项目管理分支缺少相关目录\n* 推送至hexo分支\n```bash\n$ vim .gitignore\n\n.DS_Store\nThumbs.db\n*.log\n.deploy*/\n\n$ git add .gitignore \n$ git commit -m \"\"\n$ git push origin hexo\n```\n\n##  新建编辑CNAME 自动\b映射对应的域名\n* 填写自己访问的博客地址\n* ps 这个是我的域名，请换成自己的\n* 推送至hexo分支\n```bash\n$ vim source/CNAME\nblog.wudd.top\n\n$ git add . \n$ git commit -m \"\"\n$ git push origin hexo\n```\n\n\n##  发布博客以及推送操作\n```bash\n#新建博客\n$ hexo new \"博客名\"\nINFO  Created: ~/me/blog/fast/fastZhe.github.io/source/_posts/hexo安装部署教程.md\n#编辑博客\n$ vim ~/me/blog/fast/fastZhe.github.io/source/_posts/hexo安装部署教程.md\n#推送至远程项目目录进行保存分支为hexo（保存项目目录，多机操作）\n$ git add .\n$ git commit -m \"最新博客等。。。\"\n$ git push origin hexo\n#生成博客\n$ hexo g\n#本地预览（在本地验证博客是否有问题）,访问以下地址即可\n$ hexo server\n➜  fastZhe.github.io git:(hexo) ✗ hexo server\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n\n#部署博客至githubpage\nhexo d\n```\n\n### 打开页面 \b你的域名，请尽情欣赏吧！！！\n","tags":["hexo"]},{"title":"Hello World","url":"/2018/01/30/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!--more-->\n\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]